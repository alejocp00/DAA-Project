\documentclass{article}

\usepackage[spanish]{babel}

\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{listings}

\lstset{
    language=Python,
    basicstyle=\ttfamily,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{green},
    frame=single,
    breaklines=true,
    numberstyle=\tiny\color{gray},
    numbersep=5pt,
    xleftmargin=5pt,
    showstringspaces=false
}


\title{Ejercicio 3 \\ El Problema de los Subuniversos}
\date{}

\begin{document}
\maketitle
\large
\section{Ejercicio}

Se tiene un universo principal \(U\) con varias leyes.
\[U = \{ l_1, l_2, \dots, l_n \}\]
Sean \(C_1, C_2, \dots, C_k\) subuniversos donde cada uno presenta un subconjunto de leyes del universo principal. Se desea saber si existe un conjunto de estos subuniversos tal que su unión formen el universo principal y que sean disjuntos entre sí.


\section{Solución}

\subsection{Cobertura exacta de conjuntos / Exact Set Cover}

Analizando el ejercicio podemos ver que es una instancia de un problema NP-Completo conocido, Exact Set Cover o Exact Cover.

Definición (Exact Set Cover):

\begin{itemize}
\item Entrada:
    \begin{itemize}
    \item Un conjunto finito \(X\)(universo)
    \item Una colección \(S\) de subconjuntos de \(X\)
    \end{itemize}
\item Pregunta:
    \begin{itemize}
    \item ¿Existe una subcolección \(T\) $\subseteq$ \(S\)  tal que cada elemento de \(X\) pertenece exactamente a un subconjunto en \(T\)?
    \end{itemize}
\end{itemize}

Mapeo de Instancias
\begin{itemize}
\item Universo:
    \begin{itemize}
    \item Asignamos \(U\) = \(X\)
    \end{itemize}
\item Subconjuntos:
    \begin{itemize}
    \item Asignamos \(C\) = \(S\)
    \end{itemize}
\item Objetivo:
    \begin{itemize}
    \item Encontrar una subcolección de \(C\) que cubra cada elemento de \(U\) exactamente una vez.
    \end{itemize}
\end{itemize}

Como podemos ver la estructura y pregunta de ambos problemas son idénticas.
Por lo que podemos afirmar que el problema de los subuniversos es una instancia de Exact Set Cover.


\subsection{Demostración NP-Completo}

\textbf{Demostración NP:}

Para demostrar que el problema está en NP, tenemos que verificar que en tiempo polinomial una solución candidata sea válida. \\

\textbf{Verificación:}

\textbf{Cobertura Completa:} Verificamos que la unión de los subconjuntos seleccionados es igual a \(U\). Podemos construir la unión iterando sobre cada conjunto seleccionado y agregando sus elementos a un conjunto auxiliar.

\textbf{Cobertura Exacta:} Verificamos que no hay solapamientos entre los conjuntos seleccionados. Mantenemos un conjunto auxiliar y comprobamos que cada elemento se agrega exactamente una vez. Si encontramos un elemento que ya está en el conjunto auxiliar al procesar un nuevo subconjunto, entonces hay solapamiento.

\textbf{Tiempo Requerido:} $O(\sum_{s\in S'} |s|)$ donde \(S'\) es la subcolección seleccionada.

La verificación se puede realizar en tiempo polinomial respecto al tamaño del universo \(U\) y el total de elementos en los subconjuntos seleccionados.
\\

\textbf{Demostrar NP-Hard:}
 Demostremos que el enigma de los subuniversos es NP-Hard mediante una reducción desde el problema SAT que es conocido por ser NP-Completo.
 \\

\textbf{Descripción de SAT:}
\begin{itemize}
\item Entrada:
    \begin{itemize}
    \item Un conjunto de varaibles booleanas \(B = \)$\{b_1,b_2, \dots, b_n\}$
    \item Una fórmula \(f\) en forma normal conjuntiva (FNC), donde cada cláusula $C_i$ es la disyunción de literales(variables o su negación).
    \end{itemize}
\item Pregunta:
    \begin{itemize}
    \item ¿Existe una asignación de valores de verdad a las variables en \(B\) que satisfaga todas las cláusulas de \(f\)?\\
    \end{itemize}
\end{itemize}

\textbf{Reducción}

Demostremos que es Exact Set Cover es NP-Hard. Para ello vamos a utilizar una reducción de un problema conocido que sabemos que es NP-Hard a este.
Utilizaremos SAT, en este problema se tiene  una expresión booleana en forma normal conjuntiva.

Dada una instancia de SAT:

f = $C_1$ $\wedge$ $C_2$ $\wedge$ \dots $\wedge$ $C_n$
donde $C_i$ = \{ $x_{i1}$ $\vee$ $x_{i2}$ $\vee$ \dots $\vee$ $x_{ik}$\}
y \(x_{i,j}\)=\{ True or False, de la forma $\neg$$x_{i,j}$ o $x_{i,j}$\}\\

Definamos un conjunto \(U\) y una familia de subconjuntos \(F\).

El conjunto universo \(U\) consistira de 3 tipos de elementos:

\begin{itemize}
    \item $x_i$: por cada variable i
    \item $C_j$:: por cada cláusula j
    \item $p_{i,j}$ por cada aparición de la variable i en la cláusula j \\
\end{itemize} 



Para el conjunto \(F\) tendremos:
\begin{itemize}
    \item Por cada variable i creamos dos conjuntos, el conjunto verdadero $x_{i}^{T}$ y el conjunto falso $x_{i}^{F}$. El conjunto verdadero contiene $x_i$ en conjunto a las apariciones de \(i\) en cada cláusula \(j\) donde aparezca negada(los $p_{i,j}$ donde $i$ sea falso) y el conjunto falso contiene $x_i$ junto a las apariciones de \(i\) en cada cláusula \(j\) donde no aparezca negada (los $p_{i,j}$ donde $i$ sea verdadero).\\

    \textbf{Ejemplo:} Si $x_1$ aparece en la cláusula 2 y $\neg$$x_1$ aparece en las clausulas 3 y 4 creamos los conjuntos:

    $x_{1}^{T}$ = \{$x_1$,$p_{1,2}$\} y $x_{1}^{F}$ = \{$x_1$,$p_{1,3}$,$p_{1,4}$\}\\
    \item Por cada elemento $p_{i,j}$ creamos un conjunto \{$C_j$, $p_{i,j}$\}
    \item Luego por cada $p_{i,j}$ crearemos subconjuntos por cada uno donde sea su único elemento. $\{p_{i.j}\}$.
\end{itemize}



\textbf{Ejemplo de la construción}:

$f = $   \{ $x_{1}$ $\vee$ $x_{2}$ $\vee$ $\neg$ $x_{3}$\} $\wedge$ \{ $\neg$ $x_{1}$ $\vee$ $x_{2}$ $\vee$ $x_{3}$\}

Creamos los conjuntos verdaderos y falsos

\begin{itemize}
    \item $x_{1}^{T}$ = \{$x_1$, $p_{1,2}$\}
    \item $x_{1}^{F}$ = \{$x_1$, $p_{1,1}$\}
    \item $x_{2}^{T}$ = \{$x_2$\}
    \item $x_{2}^{F}$ = \{$x_2$, $p_{2,1}$, $p_{2,2}$\}
    \item $x_{3}^{T}$ = \{$x_3$, $p_{3,1}$\}
    \item $x_{3}^{F}$ = \{$x_3$, $p_{3,2}$\}
\end{itemize}

Creamos los conjuntos de cláusulas con sus $p_{i,j}$

\begin{itemize}
    \item \{$C_1$, $p_{1,1}$\}, \{$C_1$, $p_{2,1}$\}, \{$C_1$, $p_{3,1}$\}
    \item \{$C_2$, $p_{1,2}$\}, \{$C_2$, $p_{2,2}$\}, \{$C_2$, $p_{3,2}$\}
    \item \{$C_3$, $p_{1,3}$\}, \{$C_3$, $p_{2,3}$\}, \{$C_3$, $p_{3,3}$\}
\end{itemize}

y los conjuntos independientes de $p_{i,j}$: \\

$\{p_{1,1}\}$, $\{p_{1,2}\}$, $\{p_{1,3}\}$, $\{p_{2,1}\}$, $\{p_{2,2}\}$, $\{p_{2,3}\}$, $\{p_{3,1}\}$, $\{p_{3,2}\}$,$\{p_{3,3}\}$. \\

Sea el conjunto
\begin{multline}
    F = \{ \{p_{1,1}\}, \{p_{2,1}\},\{p_{3,1}\},\{p_{1,2}\},\{p_{2,2}\},
    \{p_{3,2}\},\{p_{1,3}\}, \{p_{2,3}\},\{p_{3,3}\}, x_{1}^{T}, 
    x_{1}^{F}, x_{2}^{T}, x_{2}^{F}, x_{3}^{T}, x_{3}^{F},\\
    \{C_1, p_{1,1}\}, \{C_1, p_{2,1}\}, \{C_1, p_{3,1}\}
    \{C_2, p_{1,2}\}, \{C_2, p_{2,2}\}, \{C_2, p_{3,2}\} \{C_3, p_{1,3}\},
    \{C_3, p_{2,3}\}, \{C_3, p_{3,3}\}\}\
\end{multline} 

Sea el universo

\[U = \{x_1, x_2, x_3, C_1, C_2, p_{1,1}, p_{1,2}, p_{1,3}, p_{2,1}, p_{2,2} ,p_{2,3}, p_{3,1}, p_{3,2}, p_{3,3}\}\]


Definamos una instancia de Exact Set Cover donde el conjunto universo sera representado por el conjunto \(U\) y el conjunto de subconjuntos por \(F\).
Tendremos que:
\[U = \{ x_i, C_j, p_{i,j}\}\]

\[F = \{x_{i}^{T}, x_{i}^{F}, \{C_j, p_{i,j}\}, \{p_{i,j}\}\}\]

para  $0 \leq i \leq n$ y  $0 \leq j \leq k$. \\

Vamos a demostrar que si se tiene una asignacion de las variables que satisface la expresión(o sea, que resuelve SAT), entonces existe un subconjunto $T \subseteq F$ que satisface la instancia de Exact Set Cover que se creo. \\

Teniendo la asignación que resuelve SAT vamos a armar un subconjunto:
\begin{itemize}
    \item Tomamos el conjunto $x_{i}^{T}$ o $x_{i}^{F}$ dependiendo si $x_i$ es verdadero o falso.
    \item Tomamos los conjuntos ${C_j, p_{i,j}}$ dependiendo si $x_i$ se encuentra en la cláusula $j$.
    \item Tomamos los conjuntos $p_{i,j}$ de los restantes $x_i$ ya que solo podemos escoger $k$ de los subconjuntos ${C_j, p_{i,j}}$, por ser $k$ la cantidad de cláusulas. Para evitar la interseccion entre conjuntos. \\
\end{itemize}

\textbf{Podemos ver que}:
\begin{itemize}
    \item Construimos un subconjunto que forma el universo ya que al escoger los conjuntos $x_{i}^{T}$ o $x_{i}^{F}$, obtenemos todos los $x_i$ y los $p_{i,j}$, donde era falso o verdadero respectivamente. Luego obtenemos los $C_j$ de los ${C_j, p_{i,j}}$ y los $p_{i,j}$ donde se encontraban los $x_i$ y luego completamos con los $p_{i,j}$ restantes.
    \item Los subconjuntos son disjuntos entre sí ya que al escoger los $x_{i}^{T}$ o $x_{i}^{F}$ se escogen los $p_{i,j}$ donde es falso o verdadero respectivamente pues no habrá intersección con los $p_{i,j}$ escogidos en ${C_j, p_{i,j}}$ pues se seleccionarán donde aparece ese $x_i$ en su respectiva cláusula que es lo contrario de los $x_{i}^{T}$ o $x_{i}^{F}$. \\
\end{itemize}

\textbf{Ejemplo de solución:}

Dada una solución cualquiera de SAT, sea esta:
\[s = \neg x_1 \wedge x_2 \wedge x_3\]

cubriremos el universo, dando como resultado el subconjunto 
\[T = \{ x_{2}^{T}, x_{1}^{F}, x_{3}^{T}, \{C_1, p_{2,1}\}, \{C_2, p_{1,2}\}, \{p_{2,2}\}, \{p_{3,2}\} \}\]

Por tanto queda demostrado que si existe una solución al problema SAT podemos construir a partir de esta una solución al Exact Set Cover en tiempo polinomial. 

Ahora vamos a hacer la demostración en el otro sentido.
Demostremos que si existe una solución de Exact Set Cover entonces podemos contruir una solución para SAT.

Teniendo un subconjunto $T \subseteq F$ que de foma que la union de sus elementos formen el universo y no exista intersección entre ellos. Sea esta una solución de Exact Set Cover.

\begin{itemize}
    \item Asignamos verdadero a $x_i$  si aparece $x_{i}^{T}$ en el subconjunto, mientras que asignamos falso a $x_i$ si aparece $x_{i}^{F}$.
    \item Luego verificamos las clausulas, donde por cada clausula $C_j$ al menos uno de los conjuntos ${C_j, p_{i,j}}$ debe aparecer en $T$. Si $C_j$ no esta cubierta por ninguno de estos conjuntos entonces la fórmula SAT no es satisfacible.
\end{itemize}

De modo general tenemos que en cada cláusula debe haber una variable en verdadero, lo que hace que se satisfaga la ecuación y por tanto la asignacion realizada resuelve el SAT.

La solución de Exact Set Cover proporciona una cobertura exacta del universo, lo que permite determinar directamente los valores de verdad de las variables en la fórmula SAT original.

Finalmente hemos demostrado que se puede construir una solucion para SAT a partir de una para Exact Set Cover en tiempo polinomial, como SAT es NP-Hard entonces Exact Set Cover es NP-Hard.
Finalmente como Exact Set Cover es NP y NP-Hard es también NP-Completo.


\subsection{Algoritmo}

\textbf{Backtrack}

Para la solución de este problema, planteamos un algoritmo de backtrack que iteramos por cada conjunto y vamos agregando si no existe solapamiento. Termina si encuentra una solución y la devuelve, si no, devuelve vacío.

\begin{lstlisting}
def exact_set_cover(universe, subsets):
    used_subsets = []

    def backtrack(covered, index):
        if covered == universe:
            return True
        if index >= len(subsets):
            return False

        for i in range(index, len(subsets)):
            subset = subsets[i]

            if not covered & subset:
                used_subsets.append(subset)
                if backtrack(covered | subset, i + 1):
                    return True
                used_subsets.pop()
        return False

    if backtrack(set(), 0):
        return used_subsets
    else:
        return None
\end{lstlisting}

Podemos ver que es un algoritmo bastante sencillo pero ineficiente ya que recorre todos los posibles subconjuntos.\\

\textbf{Análisis de Complejidad}

\begin{itemize}
    \item Búsqueda exhaustiva: La función backtrack explora todas las posibles combinaciones de subconjuntos. En el peor caso, esto implica considerar $2^n$ combinaciones, donde n es el número de subconjuntos.
    \item Verificación de cobertura: En cada llamada recursiva de backtrack, se verifica si la unión de los subconjuntos seleccionados cubre el universo. Esto puede requerir hasta $O(n * m)$ operaciones, donde m es el número de elementos en el universo.
\end{itemize}

La complejidad temporal total de la solución de fuerza bruta es $O(2^n * n * m)$.\\

\textbf{Greedy Conjunto de Mayor Tamaño}

Como el anterior es muy ineficiente para mejorar la eficiciencia del algoritmo usamos un enfoque greedy donde siempre a la hora de agregar tomamos el conjunto con mayor cantidad de elementos.\\

A pesar de que puede ser útil para encontrar soluciones aproximadas al problema de Exact Cover, sin embargo, no es un algoritmo polinomial en el sentido estricto y su rendimiento puede variar significativamente dependiendo de la instancia del problema.
No garantiza optimalidad pero en este problema no se busca optimalidad.

Heurística intuitiva: La idea de seleccionar en cada paso el conjunto que cubre la mayor cantidad de elementos restantes parece una estrategia lógica.
Reducción del espacio de búsqueda: Al eliminar los elementos cubiertos en cada iteración, se reduce significativamente el espacio de búsqueda, lo que puede acelerar la búsqueda de una solución.

Entonces, ¿cuándo funciona bien el algoritmo greedy para Cobertura Exacta?

Conjuntos con poco solapamiento: Si los conjuntos tienen pocos elementos en común, el algoritmo greedy tiene más probabilidades de encontrar una solución rápidamente.
Instancias "fáciles": En instancias donde la estructura de los conjuntos favorece la estrategia greedy, el algoritmo puede encontrar una solución óptima o cercana a la óptima.

\textbf{Resultados:}

Para un universo \(U\) de 30 elementos y un conjunto \(S\) de 75 subuniversos. \\

\textbf{Backtrack}: 0.03481864929199219 ms.

\textbf{Greedy Conjunto Mayor Tamaño}: 0.006000041961669922ms.

Podemos observar que el algoritmo greedy es más eficiente que el de backtrack.

\subsection{Solución utilizando Programación Lineal Entera (PLE)}

La Programación Lineal Entera (PLE) es una técnica de optimización matemática que busca minimizar o maximizar una función objetivo sujeta a restricciones lineales, donde algunas o todas las variables deben tomar valores enteros. Es una extensión de la Programación Lineal (PL), donde las variables pueden ser fraccionarias, pero en PLE se restringen a valores enteros, comúnmente binarios (0 o 1) en problemas de selección.

El objetivo es seleccionar un subconjunto de los subconjuntos disponibles que cubra exactamente todos los elementos del universo sin solapamientos.

Definimos variables binarias que indican si un subconjunto es seleccionado o no.

\subsubsection{Formulación matemática}

- Variables de decisión

Sea $x_i$ una variable binaria asociada al subconjunto $S_i$:

\begin{equation}
x_i = \begin{cases}
1 & \text{si el subconjunto } S_i \text{ está en la solución} \\
0 & \text{en caso contrario}
\end{cases}
\end{equation}

- Función objetivo

Aunque nuestro objetivo principal es encontrar una cobertura exacta, podemos formular una función objetivo que minimice el número de subconjuntos seleccionados (esto es opcional si solo buscamos factibilidad):

\begin{equation}
\text{Minimizar } Z = \sum_i x_i
\end{equation}

Si solo buscamos una solución factible y no nos importa el número de subconjuntos, podemos omitir la función objetivo o simplemente buscar cualquier solución que satisfaga las restricciones.

- Restricciones

Para asegurar que cada elemento $e$ del universo $U$ sea cubierto exactamente una vez, establecemos:

\begin{equation}
\sum_{i: e \in S_i} x_i = 1 \quad \forall e \in U
\end{equation}

Esto garantiza que cada elemento $e$ esté en exactamente un subconjunto seleccionado.

\subsubsection{Análisis de la formulación}

- Cobertura Exacta

Las restricciones aseguran que cada elemento del universo sea cubierto una sola vez.

- Selección de Subconjuntos

Las variables de decisión $x_i$ controlan qué subconjuntos se incluyen en la solución.

- Factibilidad

Cualquier solución que satisfaga las restricciones representa una cobertura exacta del universo.

\subsubsection{Naturaleza de la solución}

La PLE encuentra una solución que cumple exactamente con las restricciones establecidas. A diferencia de métodos heurísticos o algoritmos aproximados, la PLE garantiza encontrar una solución óptima o determinar que no existe.


\subsubsection{Eficiencia comparada con Backtrack}

El Backtrack implica probar todas las posibles combinaciones de subconjuntos, lo cual es computacionalmente inviable para conjuntos grandes debido al crecimiento exponencial. Los solvers de PLE utilizan técnicas avanzadas como ramificación y poda (branch and bound), cortes planos (cutting planes) y heurísticas para explorar el espacio de soluciones de manera eficiente. Aunque el problema sigue siendo NP-hard, los solvers pueden manejar instancias de tamaño moderado en tiempos razonables.

\subsubsection{Flexibilidad}

La PLE permite fácilmente agregar restricciones adicionales o modificar la función objetivo sin cambiar significativamente el modelo.

\subsubsection{Facilidad de implementación}

Modelar el problema como una PLE puede ser más sencillo y requiere menos esfuerzo de programación, especialmente para problemas grandes o complejos.

\subsubsection{Implementación}

\begin{lstlisting}
import pulp
from utils import generate_subsets, generate_universe
import time
from pulp import PULP_CBC_CMD

def ilp_exact_cover(universe, subsets):
prob  = pulp.LpProblem("Exact_Cover", pulp.LpMinimize)
subset_indices = range(len(subsets))

x = pulp.LpVariable.dicts('x', subset_indices, cat='Binary')

prob += pulp.lpSum([x[i] for i in subset_indices])

for e in universe:
prob += pulp.lpSum([x[i] for i in subset_indices if e in subsets[i]]) == 1

prob.solve(PULP_CBC_CMD(msg=False))

if pulp.LpStatus[prob.status] == 'Optimal':
solution = [subsets[i] for i in subset_indices if x[i].varValue == 1]
return solution
else:
return None
\end{lstlisting}



\end{document}